//*Асинхронність

//Синхронний код -  виконується послідовно, кожна інструкція очікує, доки виконається попередня. Коли ти викликаєш функцію, яка виконує тривалу дію, це зупиняє програму на увесь час її виконання. Тобто в моделі синхронного програмування все відбувається по черзі.

//В асинхронному коді - одночасно можуть виконуватися декілька операцій. У такій моделі мережевий запит на сервер не зупинить програму, вона продовжить виконувати інші операції. Коли запит завершиться, програма повідомляє про це й отримує доступ до результату (наприклад, даних із сервера).
//За одиницю часу, як і раніше, може виконуватися тільки одна операція, тому що JavaScript — однопотокова мова. Асинхронне програмування досягається шляхом відкладених викликів функцій, де ініціалізація асинхронної операції і обробка її результату — це різні дії.

//Приклад синхронного коду
console.log("First log");
console.log("Second log");
console.log("Third log");


//Приклад асинхронного

//*функцією setTimeout() приймає два параметри:
//callback-функцію, яка буде викликана після закінчення часу;
//час, після якого буде викликана функція.

//--------------------------------------------------------------------------
// Виконується першою
console.log("First log");

setTimeout(() => {
	// Виконується третьою, через 2000 мілісекунд (2 секунди)
  console.log("Second log");
}, 2000);

// Виконується другою
console.log("Third log");
//-------------------------------------------------------------------------

//В асинхронних однопотокових процесах у тебе є графік завдань, в якому деякі завдання залежать від результату роботи інших. З виконанням кожного завдання викликається код для обробки його результату.



//Багатопотоковість
//*Багатопотоковий підхід (паралелізм) — ти наймаєш двох помічників. Одного — для приготування кави, а іншого — для тостів. Тепер у тебе є проблема управління помічниками (потоками), щоб вони не конфліктували один з одним на кухні під час спільного використання ресурсів.

//-------------------------------------------------------------------------

//Тайм-аут
//Таймери реалізовані в браузері, а не вбудовані в мову, і доступні на глобальному об'єкті window.
//*Функція setTimeout планує в асинхронній черзі відкладений виклик функції, який виконується після зазначеного інтервалу часу. Вона не викликає функцію безпосередньо, а лише планує її виконання через певний час.
//*Результатом виклику setTimout() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.

const timerId = setTimeout(callback, delay, arg1, arg2, ...);

//callback — функція, виклик якої необхідно запланувати;
//delay — час у мілісекундах, через який callback-функція буде викликана один раз.
//Додаткові аргументи (arg1, arg2 тощо) не обов’язкові і будуть передані callback функції під час виклику. 

//-------------------------------------------------------------------------

//Скасування тайм-ауту
//*Метод clearTimeout(id)приймає ідентифікатор таймера та “очищає його”, тобто видаляє реєстрацію відкладеного виклику функції з черги.

const greet = () => {
console.log("Hello!");
};
const timerId = setTimeout(greet, 3000);
clearTimeout(timerId);
//У прикладі вище ми викликали clearTimeout(), який виконається раніше, ніж буде викликана функція greet(). Отже, таймер з timerId буде видалений і реєстрація відкладеного виклику greet() скасується. Тому в консоль нічого не виведеться.

//----------------------------------------------------------------------------


//Інтервал

//*Метод setInterval() — це простий спосіб повторення коду знову і знову з певним інтервалом.Синтаксис і параметри такі самі, як у setTimeout().
const intervalId = setInterval(callback, delay, arg1, arg2, ...);

//На відміну від setTimeout(), інтервал запускає виконання функції не один раз, а регулярно повторює її через вказаний проміжок часу.
//Результатом виклику setInterval() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.
//У браузерного таймера є мінімально можлива затримка, вона коливається приблизно від 0 до 4 мілісекунд. За стандартом, мінімальна затримка становить 4 мілісекунди, тому різниці між setInterval(cb, 1) і setInterval(cb, 4) немає.

//-------------------------------------------------------------------------------
//Скасування інтервалу

//Якщо з якихось причин нам потрібно скасувати виконання функції, зареєстрованої інтервалом, використовується метод clearInterval.
//*clearInterval(id) - Він приймає ідентифікатор інтервалу та очищає його, тобто видаляє виклики, зареєстровані переданим інтервалом з асинхронної черги.
