//*Ключове слово - this
//Під час виклику функції у this записується посилання на об'єкт, 
//у контексті якого вона була викликана. 
//Таким чином, у тілі функції ми можемо отримати доступ до властивостей і методів цього об'єкта.
const user = {
    username: "Victor",
    showName() {
          // ✅ Віктор біжить швидко, тому що він (this) намагається зловити поїзд.
      console.log(this.username);
    },
  };
  user.showName();
//Метод showName — це функція, яка викликається в контексті об'єкта user.
// Під час її виклику в this записується посилання на об'єкт user, і ми можемо звертатися до його властивостей і методів.
//! 1)this визначається тим, як саме функцію викликали, а не де вона була оголошена.
//! 2)У глобальному контексті,не в суворому режимі  - this посилається на об'єкт window.
//Об'єкт window надає доступ до браузерних властивостей і функцій та є глобальним контекстом виконання для скриптів у браузері.
//! 3)У суворому режимі,у глобальному контексті - this  завжди  undefined.

//Якщо функція була викликана як метод об'єкта, то контекст вказуватиме на сам об'єкт,
// якому належить цей метод.
const user = {
    username: "Poly",
    showThis() {
      console.log(this);
    }
  };
  user.showThis(); // {username: "Poly", showThis: ƒ}


//*Метод call()
// Коли функцію потрібно викликати в контексті об'єкта, 
// навіть якщо функція не є методом цього об'єкта. 
//Для цього є методи:
//call, apply, bind, які дозволяють вказати контекст виклику функції.,
//Сигнатура — це ім'я методу і його параметри.
foo.call(thisArg, arg1, arg2, ...)
//thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції
//arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції

function showName() {
	console.log(this.name);
}
const user = {
  name: "Alice",
};
console.log(showName.call(user));
//Метод call слід викликати на функції, передаючи аргументом об'єкт, 
//який буде встановлювати контекст (this) для цієї функції. 
//У цьому випадку showName є функцією, і ми встановлюємо контекстом об'єкт user,
// щоб вона могла отримати доступ до його властивості name.


//*Метод apply()
//в методі apply() синтаксис передачі аргументів вимагає масиву, 
//навіть якщо аргументи функції — це окремі значення.
foo.apply(thisArg, [arg1, arg2, ...])
//thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції.
//arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції.
//Тобто різниця між call і apply полягає лише у формі передачі аргументів. 
function greet(str) {
    console.log(`${str}, ${this.username}, your room is ${this.room}!`);
  }
  const mango = {
    username: "Mango",
      room: 27
  };
  const poly = {
    username: "Poly",
      room: 191
  };
  greet.apply(mango, ["Welcome"]); // "Welcome, Mango, your room is 27!"
  greet.apply(poly, ["Aloha"]); // "Aloha, Poly, your room is 191!"


  //*Метод bind()
  //Методи call і apply викликають функцію «на місці», тобто одразу.
//Метод bind створює і повертає нову функцію, яка має заздалегідь встановлений контекст,
// і ця нова функція може бути викликана пізніше з будь-якими аргументами.
const boundFoo = foo.bind(thisArg, arg1, arg2, ...)
//thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції
//arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції при її виклику

function.bind(context)
//Для виклику методу bind використовується function.bind(context),
// де function — це функція, для якої треба створити прив'язану версію, 
//context — це об'єкт, який потрібно встановити як новий контекст (значення this) для цієї функції.
















//*Процедурне програмування - 
//де програми структуровані у вигляді набору функцій, які виконують певні дії над даними.
//Основні концепції:
// 1. Процедури (функції): Основною одиницею програми є функції які приймають аргументи (вхідні дані), обробляють їх і можуть повертати результат (вихідні дані).
// 2. Локальні та глобальні змінні: Змінні, що оголошуються в межах функції, є локальними й доступними лише в цій функції.
// Змінні, оголошені поза функціями, є глобальними й доступними в усій програмі.

//Процедурний код — це набір не пов'язаних явно функцій і змінних для зберігання й обробки інформації. 
//Цей підхід — простий і прямолінійний. Він може використовуватись для задач, в яких немає тісно пов'язаних сутностей (даних і функцій для їх обробки).
const baseSalary = 2300;
const overtime = 20;
const rate = 50;
const getWage = (baseSalary, overtime, rate) => {
    return baseSalary + overtime * rate;
};
getWage(baseSalary, overtime, rate);

// Процедурне програмування - 1. є простим і зрозумілим; 2. може бути використане для написання простих програм; 3. --- зі збільшенням складності програми процедурний підхід може стати неефективним, оскільки втрачається зв'язок між даними й методами їх обробки.


//*Об'єктно-орієнтоване програмування (ООП) - програми структуровані як сукупність об'єктів.
//1)Ці об’єкти представляють реальні або абстрактні сутності: користувач, магазин, автомобіль тощо.
//2)Кожен з об’єктів містить дані (властивості) і методи для взаємодії з ними.
//3)допомагає структурувати код, 
//4)полегшує його розробку та підтримку, 
//5)дозволяє створювати більш складні програми, організовані навколо об'єктів та їх взаємодії.
//!6)При такому підході відсутні або майже відсутні глобальні змінні.
 //!7)Методи не залежать від параметрів, а використовують властивості об'єкта, які задаються при його створенні і можуть бути змінені іншими методами.
const employee = {
    baseSalary: 5600,
    overtime: 10,
    rate: 80,
getWages () {
    return this.baseSalary + this.overtime * this.rate;
},
};
employee.getWages();



//* 4. Клас
//це спосіб опису сутності, що визначає структуру та поведінку об'єктів, а також правила для взаємодії з цією сутністю (контракт).
// Вони виступають в якості шаблонів для створення нових об'єктів.
//У нашому прикладі клас визначає сутність: автомобіль. - Властивостями класу будуть запчастини: двигун, колеса, фари тощо.
//-Методами класу будуть дії: відчинити двері, завести двигун, збільшити швидкість тощо.
//кожен автомобіль унікальний - номер кузова і двигуна, за кольором, оздобленням салону.Ці автомобілі — це екземпляри класу.


//Екземпляр (об'єкт, інстанція) — це окремий представник класу, який має дані (властивості) і методи (функції), які працюють з цими даними. 
//Екземпляр — це те, що створено за кресленням, тобто на підставі опису з класу.

// Клас — це якийсь абстрактний автомобіль на кресленні
// Екземпляр (об'єкт) — це конкретний автомобіль, що стоїть у нас під вікнами.

//*Інтерфейс класу - 
//Інтерфейс — це набір властивостей і методів класу, доступних для використання у роботі з екземпляром.
//Гарний приклад інтерфейсу — панель приладів автомобіля, яка дозволяє викликати методи, наприклад, збільшення швидкості, гальмування, повороти, перемикання передач, увімкнення фар тощо.





//*Класи - Шаблон на основі якого створюються нові обʼєкти.
//Оголошення класу:

class User {
  // Тіло класу
}

//Після того як клас було оголошено, можна створити його екземпляр за допомогою спеціального оператора new, поставивши його перед викликом класу. 
//!! 4.1 Результатом виклику new User() буде екземпляр класу User. 
//Він буде містити дані і мати поведінку, що описані у класі.

const mangos = new User();
console.log(mangos); // {}

const polys = new User();
console.log(polys); // {}

//Example:
class Books {
  // Тіло класу
}
const virtual = new Books();
console.log(virtual);
const online = new Books();
console.log(online);

//!! 4.2 Constructor - Для ініціалізації екземпляра класу використовується цей метод.
//Якщо його не визначити -> буде порожня функція, яка не змінює екземпляр класу.

class User {
  // Синтаксис оголошення методу класу
  constructor() {
		// ...
  }
}
//Виклик класу з оператором new призводить до створення нового об'єкта й автоматичного виклику методу constructor.
class User {
  constructor(name, surname){
        // Ініціалізація властивостей екземпляра
        this.name = name;
        this.surname = surname;
  }
}

const user2 = new User("Hanna", "Korol"); //
console.log(user2); // { name: "Hanna", surname: "Korol" }

//Властивості name та surname називаються публічними властивостями, оскільки вони є власними властивостями об'єкта-екземпляра.

//!! 4.3 Об'єкт параметрів - params - передаючи один об'єкт з логічно іменованими властивостями
class User {
  constructor(params) {
    this.name = params.name;
    this.email = params.surname;
  }
}

//!!4.4 Методи класу - це функції, які будуть доступні екземпляру в його прототипі.
//1.Вони оголошуються в довільному порядку після конструктора. 
//2. Методи класу не розділені жодними спеціальними символами.
//3. Для доступу до властивостей у методах використовується ключове слово this, 
//оскільки методи будуть викликані в контексті об'єкта-екземпляра.
//4.Методи класу не стають власними властивостями екземпляра.
//5.Методи класу додаються до спеціального об'єкта, який зберігається у властивості prototype самого класу.
class User {
  constructor(params) {
    this.name = params.name;
    this.surname = params.surname;
  }

  // Метод getName
  getName() {
		return this.name;
  }

  // Метод changeName
  changeName(newName) {
		 this.name = newName;
  }
}
// Після створення екземпляра можна використовувати оголошені методи класу,
// які будуть звертатися до властивостей об'єкта, що їх викликав.
const client = new User({ 
	name: "Hanna", 
	surname: "Makowski" 
});

console.log(client.getName()); // "Hanna"

client.changeName("Anna");

console.log(client.getName()); // "Anna"



//! 4.5 Прототип екземпляру
//1. Методи класу не стають власними властивостями екземпляра. І це правильно, оскільки, на відміну від значень властивостей, вони не є унікальними. 
//Це одна й та сама функція, яка викликається в контексті різних об'єктів. Немає сенсу копіювати методи для кожного екземпляра, враховуючи, що може існувати багато тисяч екземплярів.
//2. Методи класу додаються до спеціального об'єкта, який зберігається у властивості prototype самого класу:

/* class User {
  constructor(params) {
    this.name = params.name;
    this.email = params.email;
  }

  getEmail() {
    return this.email;
  }

  changeEmail(newEmail) {
    this.email = newEmail;
  }
} */

console.log(User.prototype); // {constructor: ƒ, getEmail: ƒ, changeEmail: ƒ}

//При створенні екземпляра через new, об'єкт, збережений у властивості prototype класу, автоматично стає його прототипом. 
//Це означає, що властивість [[Prototype]] екземпляра отримує посилання на властивість prototype класу.

//! 4.6 Приватні властивості
//Інкапсуляція — це парадигма ООП, яка передбачає приховування деталей внутрішньої реалізації класу від зовнішнього коду. 
//Інкапсуляція реалізується приватними властивостями та методами, доступ до яких можна отримати тільки всередині класу.
// публічні властивості - додаються у екземпляр та наслідуються
this.brand = brand;
this.model = model;
this.price = price;

// !приватна властивість - не додається у екземпляр та не наслідується (вона доступна тільки всередині класу і все). Приватні властивості потрібно оголошувати у самому класу (за межами конструктору)
this.#owner = owner;

//---------------------------------------------
class User {
  // Необов'язкове оголошення публічних властивостей
  name;
  // Обов'язкове оголошення приватних властивостей!!!
  #email;

  constructor(params) {
    this.name = params.name;
    this.#email = params.email;
  }
}

const mango = new User({
  name: "Mango",
  email: "mango@mail.com",
});
console.log(mango.name); // "Mango"
console.log(mango.#email); // Виникне помилка, це приватна властивість
//------------------------------------------------

// !приватний метод - його можна викликати тільки в самому класі, він не наслідується і не додається у екземпляри
#checkOwner() {
  const userAnswer = prompt(
    "Введіть поточного власника для підтвердження операції:"
  );
  return userAnswer === this.#owner;
}

// Для того щоб отримати або змінити значення приватної властивості використовуються публічні методи.

// публічний метод - його можна викликати з будь-якого екземпляру (він наслідується та додається у екземпляри)
displayCarInfo() {
  console.log(
    `Марка: ${this.brand}\nМодель: ${this.model}\nЦіна: ${this.price}$`
  );
}


//! 4.7 Геттери (get-читання)  і сеттери (set-перезапис)
  // методи аксесори - це спеціальні синтакстичні конструкції за допомогою яких ми можемо прочитати або перезаписати приватні властивості (накливши деякі обмеження чи перевірки). Згадуйте про викрутку для чайнику.
  // get (читання) set (перезапис)
/* class User {
  #email;

  constructor(params) {
    this.name = params.name;
    this.#email = params.email;
  } */

  // Геттер email— це функція, яка дозволяє отримати значення властивості класу.
  get email() {
    return this.#email;
  }

  // Сеттер email
  set email(newEmail) {
    this.#email = newEmail;
  }
/* } */

//  повертаємо значення приватної властивості #email за допомогою геттера
//змінюємо її значення за допомогою сеттера
//Геттер і сеттер повинні називатися однаково. 
//Краще називати геттери і сеттери так само, як і властивість, з якою вони працюють. Але це не є вимогою синтаксису. 
//Геттер може існувати без сеттера, так само як і сеттер без геттера.
//Геттери і сеттери доречно використовувати для простих операцій читання та зміни значення властивостей, особливо приватних, як їх публічний інтерфейс.
//! Для роботи з властивістю, яка зберігає масив або об'єкт, вони не підійдуть.
class Car {
  #brand;
  #model;
  #price;

constructor(params) {
  this.#brand = params.brand;
  this.#model = params.model;
  this.#price = params.price;
}

get brand() {
  return this.#brand;
}

set brand(newBrand) {
  this.#brand = newBrand;
}

get model() {
  return this.#model;
}

set model(newModel) {
  this.#model = newModel;
}

get price() {
  return this.#price;
}

set price(newPrice) {
  this.#price = newPrice;
}
};


//! 4.8 Статичні властивості - вони доступні тільки класові, але не його екземплярам.
//1. Вони корисні для зберігання інформації, що стосується класу.
//2. Статичні властивості оголошуються в тілі класу. 
//3. Перед ім'ям властивості додається ключове слово static.
//4. Статичні властивості можна використовувати як у методах класу, так і поза класом.
class MyClass {
	static myProp = "value";
}
console.log(MyClass.myProp); // "value"

//!У екземпляра немає доступу до статичних властивостей класу.
class MyClass {
	static myProp = "value";
}
const inst = new MyClass();
console.log(inst.myProp); // undefined

//-----------------------------------------------------------------------------------
// in this example, Car.maxPrice is important!!!! as the element maxPrice is static:
class Car {
  static maxPrice = 50000;
  #price;

  constructor(params) {
    this.#price = params.price;
  }

  get price() {
    return this.#price;
  }

  set price(newPrice) {
    if (newPrice <= Car.maxPrice) {
      return this.#price = newPrice;
    }
  }
}

const audi = new Car({ price: 35000 });
console.log(audi.price); // 35000

audi.price = 49000;
console.log(audi.price); // 49000

audi.price = 51000;
console.log(audi.price); // 49000

//---------------------------------------------------------------------


//! 4.9 Статичні методи- це методи, доступні тільки класу. Вони можуть бути публічні та приватні. 
//1. Під час їх виклику ключове слово this посилається на сам клас.
//2. мають доступ до статичних властивостей класу, але не до властивостей екземпляра - статичні методи викликає сам клас, а не його екземпляри.

//! 4.10 Наслідування класів (extends)  - 
//Ключове слово -> extends <- дозволяє реалізувати наслідування класів, 
//коли один клас (дочірній, похідний) наслідує властивості й методи іншого класу (батьківського).
class Parent {}
class Child extends Parent {
  // ...
}

//! 4.11 Конструктор дочірнього класу - функцію super(args)
//У конструкторі дочірнього класу необхідно викликати спеціальну функцію super(args) — це псевдонім конструктора батьківського класу.
// якщо не викликати super у конструкторі дочірнього класу, Буде помилка при спробі доступу до this у його конструкторі

class User {
  email;

  constructor(email) {
    this.email = email;
  }

  get email() {
    return this.email;
  }

  set email(newEmail) {
    this.email = newEmail;
  }
}

class Admin extends User {
  static role = {
    BASIC: "basic",
    SUPERUSER: "superuser",
  };
  constructor(params){
    super(params.email);
    this.acess = params.access;
  }
}

const mango = new Admin({
  email: "mango@mail.com",
  access: Admin.role.SUPERUSER,
});

console.log(mango.email); // "mango@mail.com"
console.log(mango.access); // "superuser"

//! 4.12 Методи дочірнього класу
// in example below: Метод addPost — це метод дочірнього класу ContentEditor. Він буде доступний тільки екземплярам ContentEditor.


/* / Уявімо, що вище є оголошення класу User
class ContentEditor extends User {
  constructor(params) {
    super(params.email);
    this.posts = params.posts;
  } */

  addPost(post) {
    this.posts.push(post);
  }
}
/* 
const editor = new ContentEditor({ 
	email: "mango@mail.com", 
	posts: [] 
});

console.log(editor); // { #email: "mango@mail.com", posts: [], addPost: f }

editor.addPost("post-1");
editor.addPost("post-2");
console.log(editor.posts);  */// ['post-1', 'post-2']
//----------------------------------------------------------
// Another example: 

class User {
  email;

  constructor(email) {
    this.email = email;
  }

  get email() {
    return this.email;
  }

  set email(newEmail) {
    this.email = newEmail;
  }
}
class Admin extends User {
  static role = {
    BASIC: "basic",
    SUPERUSER: "superuser",
  };

  constructor(params) {
    super(params.email);
    this.access = params.access;
  }

  blacklistedEmails = []; // this is Методи дочірнього класу
    blacklist(email) {
    if (!this.blacklistedEmails.includes(email)) {
      this.blacklistedEmails.push(email);
    } };
  isBlacklisted(email) {
    return this.blacklistedEmails.includes(email);
  }
}

const mango = new Admin({
  email: "mango@mail.com",
  access: Admin.role.SUPERUSER,
});

console.log(mango.email); // "mango@mail.com"
console.log(mango.access); // "superuser"

mango.blacklist("poly@mail.com");
console.log(mango.blacklistedEmails); // ["poly@mail.com"]
console.log(mango.isBlacklisted("mango@mail.com")); // false
console.log(mango.isBlacklisted("poly@mail.com")); // true

//---------------------------------------------------------------------------








