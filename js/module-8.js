//*Поширення подій (event propagation) — це термін, що описує життєвий цикл події, який має три етапи:

    Занурення (capture phase) - подія починається на window і тоне (проходить через усі елементи-предки) до найглибшого цільового елемента, на якому відбулася подія. На схемі подія — це клік, і capturing закінчується на елементі <button>.
    Таргетинг (target phase)- подія дійшла до цільового елемента. Цей етап містить тільки повідомлення елемента про те, що на ньому відбулася дія.
    Спливання (bubble phase)- кінцева фаза, подія спливає від найглибшого, цільового елемента, через усі елементи-предки до window.

    Елемент, на якому відбулася подія, називається цільовим, або вихідним. Це завжди найглибший елемент, з якого починається спливання. Він доступний як event.target - це посилання на вихідний елемент, на якому відбулася подія, у процесі спливання вона — незмінна.

    event.currentTarget — це посилання на поточний елемент, до якого прив’язаний поточний обробник події, і до якого в результаті спливання дійшла прослуховувана подія.

    Зазвичай подія буде спливати вгору до елемента window, викликаючи всі наявні обробники на своєму шляху.
А інколи один елемент може мати кілька обробників на одну й ту саму подію.

Будь-який проміжний обробник може зупинити спливання цієї події за допомогою методів об’єкта події (event):


    event.stopPropagation() -  Зупиняє "спливання" події в DOM-дереві. Це означає, що жоден батьківський елемент не зможе відловити цю подію.
    Не заважає іншим обробникам подій виконуватися на тому ж самому елементі.

//--------------------
descendant.addEventListener("click", (event) => {
  event.stopPropagation();
  alert("Descendant click handler");
});
//------------------------

    event.stopImmediatePropagation() - Зупиняє "спливання" події так само, як event.stopPropagation().
    Також зупиняє виконання всіх інших обробників подій, які слухають цю ж подію на даному елементі, навіть якщо вони були зареєстровані перед цим.



    //*Делегування подій

Спливання дозволяє реалізувати один із найкорисніших прийомів — делегування подій(event delegation) - полягає в додаванні одного обробника на спільного предка цих елементів.

Делегування реалізується у 3 прості кроки:
1. Визначити спільного предка групи елементів для відстеження подій (типу div).
2. Зареєструвати на елементі-предку обробник події, яку ми хочемо відловлювати з групи елементів.
3. В обробнику використовувати event.target для вибору цільового елемента, на якому безпосередньо відбулась подія.

//-----------------------------------------------------
const box = document.querySelector(".box");

box.addEventListener("click", function (event) {
	console.log(event.target);Елемент, на якому відбулась подія click
});
//-----------------------------------------------------

HTML 
<div class="box">
  <button>Button 1</button>
  <button>Button 2</button>
  <button>Button 3</button>
</div>


JS 
const box = document.querySelector("div.box");

box.addEventListener("click", function (event) {
  console.log(event.target);
});

//---------------------------------------------------------

Kонцепція - делегування подій полягає в додаванні одного спільного обробника події для групи елементів.

//*Перевірка цільового елемента події

//!Обов'язково перевіряємо цільовий елемент події click.
//Це точно має бути кнопка, в іншому разі ми випадково можемо обробити клік, коли користувач клікне між кнопками, що може викликати помилку.
//Для перевірки типу елемента використовуємо властивість nodeName.




//*Бібліотеки — це набір попередньо написаних функцій, методів і класів,
//  який надає розробнику готові інструменти для вирішення певних завдань. 
//Бібліотеки створюються для полегшення розробки, оскільки дають змогу використовувати готові рішення,
// необхідні для низки завдань, без потреби писати код з нуля.

//Основні характеристики: 
1. Багаторазове використання: Бібліотеки створюються з метою повторного використання.
2. Перевизначений функціонал: Бібліотеки містять готовий код, який можна використовувати для розв'язання поширених завдань.
3. Прискорення розробки: Використання бібліотек дає змогу скоротити час розробки.
4. Суспільство та підтримка: Хороші бібліотеки часто підтримуються активною спільнотою розробників.

Приклади популярних бібліотек у JavaScript:
    Chart.js: Бібліотека для створення інтерактивних графіків і діаграм.
    Lodash: Бібліотека для роботи з масивами, об'єктами, рядками тощо, що надає безліч зручних функцій.

    
    CDN (Content Delivery Network) — це географічно розподілена мережева інфраструктура. Вона забезпечує швидку доставку контенту (такого як стилі, скрипти, зображення та інші ресурси) користувачам вебсервісів і сайтів. 
    Основна мета CDN — поліпшити продуктивність і доступність вебсайту для користувачів, зменшивши затримки під час завантаження контенту.
    
    Переваги використання CDN:
    1. Швидке завантаження контенту.
    2. Розподілене навантаження.
    3. Покращена доступність.
    4. Зниження навантаження на вихідний сервер.


    //*Підключення бібліотеки
   Для використання бібліотеки в проєкті, її необхідно підключити, тобто додати файли бібліотеки до проєкту.

   Для прикладу підключимо до проєкту бібліотеку Lodash через CDN. Підключення JavaScript бібліотеки через CDN складається з декількох кроків.
   1. На сайт CDN сервісу https://www.jsdelivr.com/ знайди необхідну бібліотеку за її ім'ям.
   2. У списку результатів обери необхідну бібліотеку, клікнувши на назву.
   3. Скопіюй HTML - код тега script, після чого відкрий свій HTML-файл і додай посилання на скрипт бібліотеки наприкінці HTML-документа.

/* ...<body>
<!-- HTML-markup -->
<!-- Lodash library script file -->
<script async src="<https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js>"></script>
<!-- Your script file -->
<script defer src="path/to/script.js"></script>
</body>
</html> */

//Підключення скрипта бібліотеки має бути до підключення твого основного файлу скриптів.
//Не забудь додати тегу script бібліотеки атрибут async. Це потрібно для того, щоб файл бібліотеки завантажувався якомога швидше.

//Усі сучасні бібліотеки надають документацію та приклади використання на своїх офіційних вебсайтах, що може допомогти глибше розібратися в їхньому функціоналі.
// У більшості офіційних документацій до бібліотек інструкції зі встановлення та підключення до проєкту найчастіше розташовані в розділах, які мають назви "Get Started", "Quick Start", "Installation", "Setup" або подібні.
//Більшість документацій надає різноманітні приклади використання, які можна адаптувати для своїх потреб. Це часто зображено в розділах "Usage", "Examples", "API" або "Demo". ****

//Дуже важливим розділом у документації до будь-якої бібліотеки є розділ, який описує її особливості та додаткові налаштування. Цей розділ може мати різні назви в різних документаціях, але найчастіше він має назву "Options", "Advanced Settings", "Configuration Options", "Advanced Usage" або "Advanced Configuration" тощо.




//*Деструктуризація (Destructuring) - це особливий синтаксис, що дозволяє витягти значення зі структур даних, такі як об'єкти або масиви, і присвоїти їх змінним.
//Це зручний спосіб дістати потрібні дані зі складних структур і використовувати їх у коді.

//Із деструктуризацією робота з властивостями об'єкта має такий вигляд:
const user = { 
	name: "Jacob", 
	age: 32 
};

const { name, age } = user; // тут йде деструктуризація
console.log(name); // Jacob
console.log(age); // 32



//*Деструктуризація об'єктів

//Деструктуризація дозволяє «розпакувати» значення властивостей об'єкта в локальні змінні. Це робить код у місці їх використання менш «шумним».
//Правильний синтаксис деструктуризації об'єкта у змінній profile це  
//!const { } = profile. 

//Приклад дестректуризації
//------------------------------------
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

// Деструктуризуємо
const { title, author, isPublic, rating } = book;

// Використовуємо
const accessType = isPublic ? "pulbic" : "private";
const message = `Book ${title} by author ${author} with rating ${rating} is in ${accessType} access!`;
//----------------------------------------





//* Деструктуризація неіснуючих властивостей
//!У випадку, якщо "ім'я змінної" = "ім'я властивості" збігаються, то відбувається присвоєння.
//Коли в об'єкті немає властивості з таким ім'ям, змінній буде присвоєно undefined.
//З метою уникнення присвоєння undefined під час деструктуризації неіснуючих властивостей, можна задати змінним значення за замовчуванням, використовуючи знак =.

//!const { username = "Guest" } = profile

//Приклад: Додамо зображення обкладинки, якщо вона відсутня в об'єкті книги.
// -----------------------------------------------------------------
const {
  title,
  author,
  coverImage = "<https://via.placeholder.com/640/480>"
} = book;

console.log(title); // "The Last Kingdom"
console.log(author); // "Bernard Cornwell"
console.log(coverImage); // "<https://via.placeholder.com/640/480>"
//---------------------------------------------------------------------------


//*Перейменування змінної

//Під час деструктуризації можна перейменувати змінну, в яку розпаковується значення властивості, використовуючи :.

//!const { username: coolName } = profile

//Приклад: Деструктуризуємо
// -----------------------
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};
const { title, author: bookAuthor, isPublic, rating: bookRating } = book;
console.log(title); // "The Last Kingdom"
console.log(bookAuthor); // "Bernard Cornwell"
console.log(isPublic); // true
console.log(bookRating); // 8.38
//--------------------------------------------------


//*Значення за замовчуванням
//При перейменуванні змінної, в яку ми розпаковуємо значення властивості об'єкта, також можна присвоїти значення за замовчуванням.
//Для цього після нового імені ставимо дорівнює = і вказуємо її значення за замовчуванням.
//Якщо така властивість існує в об'єкті, у змінну буде присвоєно її значення.
//В іншому випадку змінній буде присвоєно значення за замовчуванням.

//--------------------------------------------------
const book = {
  title: "The Dream of a Ridiculous Man",
};

const {
  title,
  coverImage: bookCoverImage = "<https://via.placeholder.com/640/480>",
} = book;

console.log(title); // "The Dream of a Ridiculous Man"
console.log(bookCoverImage); // "<https://via.placeholder.com/640/480>"
//--------------------------------------------------------



//*Деструктуризація в циклах
//Під час ітерації по масиву об'єктів циклом for...of відбуваються багаторазові звернення до властивостей об'єкта.
//Для того щоб скоротити кількість повторень, можна деструктуризувати властивості об'єкта в локальні змінні в тілі циклу.
for (const book of books) {
  const { title, author, rating } = book;
  console.log(title);
  console.log(author);
  console.log(rating);
}

//AБO

//Якщо об'єкт містить небагато властивостей, деструктуризацію можна виконати безпосередньо в місці оголошення змінної book.
for (const { title, author, rating } of books) {
  console.log(title);
  console.log(author);
  console.log(rating);
}



//*Деструктуризація параметрів
//Під час передачі об'єктів у функції, можна деструктуризувати об'єкти, щоб отримати доступ до потрібних даних. Це дає змогу явно вказати, які поля об'єкта використовуються у функції.
function printUserInfo(user) {
  const { name, age, hobby } = user
    console.log(`Name: ${name}, Age: ${age}, Hobby: ${hobby}`);
  }
  
  printUserInfo({ 
    name: "Alice", 
    age: 25, 
    hobby: "dancing" 
  }); // Name: Alice, Age: 25, Hobby: dancing

  //АБО

  //Із деструктуризацією об'єкта в місці оголошення параметрів:
function printUserInfo({ name, age, hobby }) {
  console.log(`Name: ${name}, Age: ${age}, Hobby: ${hobby}`);
}

printUserInfo({ 
	name: "Alice", 
	age: 25, 
	hobby: "dancing" 
}); // Name: Alice, Age: 25, Hobby: dancing


//*Патерн «Об'єкт параметрів»
//Якщо функція приймає більше 2-3 параметрів, дуже просто заплутатися, в якій послідовності і що передавати.
//Патерн «Об'єкт параметрів» допомагає вирішити цю проблему.
function doStuffWithBook(book) {
  // Робимо щось з властивостями об'єкта
  console.log(book.title);
  console.log(book.pages);
  // І так далі
}

//АБО

//Це можна зробити в тілі функції.
function doStuffWithBook(book) {
  const { title, pages, downloads, rating, isPublic } = book;
  console.log(title);
  console.log(pages);
}

//Або в сигнатурі (підписі) функції — різниці немає.
function doStuffWithBook({ title, pages, downloads, rating, isPublic }) {
  console.log(title);
  console.log(pages);
}


//*Глибока деструктуризація
//Для деструктуризації властивостей вкладених об'єктів використовуються ті самі принципи. 
//1. Для початку напишемо код деструктуризації властивостей об'єкта користувача.
//2. Тепер додамо глибоку деструктуризацію властивостей об'єкта stats. Для цього в деструктуризації після імені властивості ставимо двокрапку : та починаємо деструктуризацію об'єкта для цієї властивості.
//3. Під час глибокої деструктуризації також можна змінювати імена змінних і присвоювати значення за замовчуванням, використовуючи вже знайомий тобі синтаксис.
const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  stats: {                  //деструктуризуємо саме цей обєкт в цьому випадку
    followers: 5603, 
    views: 4827,            //ця змінна буде деструктуризована далі і матиме інше імя userViews
    likes: 1308,            //ця змінна буде деструктуризована далі і матиме інше імя userLikes
  },
};

const {
  name,
  tag,
  stats: { followers = 0, views: userViews = 0, likes: userLikes = 0 }, // можна змінити імена змінних під час дуструктуризації 
} = user;

console.log(name); // Jacques Gluke
console.log(tag); // jgluke
console.log(followers); // 5603 
console.log(userViews); // 4827
console.log(userLikes); // 1308






//*Деструктуризація масивів
//Деструктуризоване присвоювання можна використовувати не тільки для об’єктів, а й для масивів, але з деякими особливостями.
//Замість фігурних дужок {} використовуються квадратні [].
//Змінним, зазначеним у квадратних дужках [], будуть послідовно присвоюватися значення елементів масиву.

//!const [ ] = fruits

//-------------------
const color = [200, 255, 100];
const [ red, green, blue ] = color;

console.log(`rgb(${red}, ${green}, ${blue})`); // “rgb(200, 255, 100)"
//-------------------------------

//*Значення за замовчуванням
//Якщо змінних оголошено більше, ніж елементів масиву, їм буде присвоєно undefined. Щоб запобігти цьому, можна вказувати значення за замовчуванням.
//Синтаксис такий самий, як в об'єктах, після імені змінної ставимо = і значення за замовчуванням.

//!const [ firstFruit = "A fruit" ] = fruits

//Приклад
//----------------------------------------------------
const color = [200, 100, 255];
const [ red, green, blue, alfa = 0.3 ] = color;

console.log(rgba(${red}, ${green}, ${blue}, ${alfa})); // “rgba(200, 255, 100, 0.3)"

//------------------------------------------------



//*Часткова деструктуризація
//Іноді з масиву необхідно деструктуризувати тільки перші N елементів, а інші зберегти в одну змінну у вигляді масиву.
//Деструктуризуючи масив, можна розпакувати перші необхідні елементи і присвоїти іншу частину елементів масиву змінній, використовуючи операцію ...rest.

//!const [ red, ...otherColors ] = color;

//ПРиклад --------------------------------------------------------------
const color = [200, 255, 100];
const [ red, ...otherColors ] = color;
console.log(red); // 200
console.log(otherColors); // [255, 100]
//При цьому оригінальний масив не змінюється, у змінній otherColor буде новий масив із копіями зібраних значень.


//З об'єктами - можна деструктуризувати певні властивості в окремі змінні, а решту зібрати в новий об'єкт.

//!const { quantity, ...otherValues } = fruit

//Приклад ----------------------------------------
const user = {
	name: "Jacob",
	age: 32,
	email: "j.cob@mail.com",
	isOnline: true
};
const { name, isOnline, ...otherProps } = user;
console.log(name); // "Jacob"
console.log(isOnline); // true
console.log(otherProps); // {age: 32, email: "j.cob@mail.com"}

//При цьому оригінальний об'єкт не змінюється, у змінній otherProps буде новий об'єкт із копіями зібраних властивостей.



//*Пропуск значень
//Припустимо, з масиву color необхідно взяти тільки останнє значення. Для цього в деструктуризації необхідно відокремити комами елементи, що пропускаються.

const rgb = [200, 100, 255];
const [, , blue] = rgb;
console.log(`Blue: ${blue}`); // "Blue: 255"
//На практиці в масивах ця можливість рідко використовується, але знати, що так можна робити, зайвим не буде.



//*Деструктуризація параметрів
//Під час передачі масиву у функцію, можна деструктуризувати його елементи.
//Із деструктуризацією в місці оголошення параметрів:

function printFruits([firstFruit, secondFruit, thirdFruit]) {
  console.log(firstFruit, secondFruit, thirdFruit);
}

printFruits(["apple", "banana", "orange"]); // "apple banana orange".


//*Переваги деструктуризації
/* 1. Зручне вилучення значень з об'єктів і масивів.
2. Короткий і читабельний код.
3. Параметри функцій:.
4. Робота з функціями, що повертають об'єкти: Якщо функція повертає об'єкт, можна відразу деструктуризувати цей об'єкт, щоб витягти з нього значення. */


https://shron1.chtyvo.org.ua/Robert_Greene/48_zakoniv_vlady.pdf?